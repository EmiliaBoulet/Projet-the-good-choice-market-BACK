# SQL

---

## Domain

Les domains sont des heritage des type de base (`TEXT` `INTEGER` `FLOAT` ...) mais avec la possibiliter de les customiser

Le type `TEXT` dit par exemple que la chaine de caractere doit etre entre simple quotes

Un domain qui herite du type `TEXT` peut en plus par exemple verifier une regex

### Création

```sql
-- On crée un domain qui herite du type TEXT
CREATE DOMAIN "dom_name" AS TEXT
CHECK (
    VALUE ~ '^[\w]+' -- On indique ce a quoi la value doit ressembler
);
```

### Utilisation

```sql
-- On peut crée notre table avec ou l'ALTER apres
CREATE TABLE "test" (
    "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "name" "dom_name" NOT NULL -- On indique que name doit respecter le domain
);
```

---

## Function

Une fonction permet de realiser quelque chose de maniere recurente

On peut faire des calcul, de nouvelles tables, des aggregations, ...

### Exemple de fonction

```sql
CREATE FUNCTION "func_price_ttc"("productId" INT) -- On donne un type a la valeur recu
RETURNS TABLE( -- On peut retourner une table, un json, un INT, un boolean, ..., un peut tout
    "price_ttc" FLOAT -- On precise bien le type en sortie
) AS $$
BEGIN
    RETURN QUERY SELECT -- Ici on retourne le resultat d'un select
            (("product"."price_ht" / 100 * "tva"."rate") + "product"."price_ht") AS "price_ttc"
        FROM "product"
        INNER JOIN "tva" ON "tva"."id" = "product"."tva_id"
        WHERE "product"."id" = $1; -- Soit on ecrit $1 soit "productId"
END;
$$  LANGUAGE plpgsql; -- On precise le language utiliser
```

---

## View

Une view permet de prendre en "photo" un element de la BDD de stocker cette "photo" et d'y acceder avec un simple select

⚠️ Attention les view ne sont pas dynamique ⚠️

Si SELECT * FROM "category"; -- C'est dynamique

Si SELECT * FROM "category" WHERE id = 1; -- On peut crée une view

```sql
-- On crée notre SELECT et on applique juste la creation d'une view avant
CREATE VIEW "view_category_sub_category" AS
SELECT
    "category"."name" AS "category",
    ARRAY_AGG("sub_category"."name") AS "sub_category"
FROM "category"
INNER JOIN "sub_category" ON "category"."id" = "sub_category"."category_id"
GROUP BY "category"."name";
```

---

## Trigger

Un trigger permet de realiser des fonction de maniere automatique

Un trigger se pose sur une table et s'applique sur les ROW de cette table

On peut crée un trigger qui se declanche lors de : `INSERT` `UPDATE` `DELETE`

### Exemple

On crée le trigger et on l'applique sur la table

```sql
CREATE TRIGGER "trig_update_user"
-- On precise quand il s'applique BEFORE -- On precise quand il s'applique UPDATE -- et sur quelle table
BEFORE UPDATE ON "user"
-- On precise que le trigger se declanche sur toutes les route
FOR EACH ROW
EXECUTE PROCEDURE "func_update_user"(); -- On indique la fonction qui va s'appliquer
```

On crée une fonction qui retourne un trigger

Cette fonction s'applique sur toutes les ROW de la table "user"
Elle remplie la column `updated_at` du user a chaque foit qu'un UPDATE est realiser sur celle ci

```sql
CREATE FUNCTION "func_update_user"() -- Pas d'argument
RETURNS TRIGGER -- On retourne un trigger
AS $$
BEGIN
    -- NEW : On prend la ROW qui vient d'etre mis a jour
    NEW."updated_at" = NOW();
    RETURN NEW; -- Retourne la nouvelle ROW avec les modification
END;
$$ LANGUAGE plpgsql;
```

2 Option possible aporter par les trigger

- `NEW` : Correspond a la ROW apres modification (utile pour les UPDATE)
- `OLD` : Correspond a la ROW avant modification (utile pour les DELETE)

---

## Index

Un index permet d'optimiser une BDD. Il s'appique sur **une** column **d'une** table

Il est utile pour les grosse base de donnée et optimise les requete SELECT quand la recheche est placer sur cette column

Un index coupe la column en petit fragment et ce qui permet de faciliter sa lecture

Le SELECT ne lira plus

- 1.2.3.4.5...1000

mais

- 1.2.3.4.5 et au meme moment
- 101.102.103.104 et au meme moment
- 1001.1002.1003.....

```sql
-- On crée notre index
-- On indique la table
-- On precise quel type d'index utiliser (voir la doc)
-- On precise la column impacter
CREATE INDEX "idx_product_name" ON "product" USING brin ("name");
```

---
